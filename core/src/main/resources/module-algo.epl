// ------------------------------ Incremental Limit Order ---------------------------------------

@Name('INCREMENTAL_FIRST_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.sendOrder')
select
    incrementalOrder.firstOrder()
from
    com.algoTrader.entity.trade.IncrementalOrder as incrementalOrder;

@Name('INCREMENTAL_MODIFY_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.modifyOrder')
select
    cast(currentOrder.parentOrder, com.algoTrader.entity.trade.IncrementalOrder).modifyOrder()
from
    pattern [every currentOrder=GenericOrder(instanceof(parentOrder,com.algoTrader.entity.trade.IncrementalOrder))
        -> (timer:interval(5 sec) and not OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, ord.extId = currentOrder.extId))]
where
    cast(currentOrder.parentOrder, com.algoTrader.entity.trade.IncrementalOrder).checkLimit();

@Name('INCREMENTAL_CANCEL_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.cancelOrder')
select
    currentOrder.parentOrder
from
    pattern [every currentOrder=GenericOrder(instanceof(parentOrder,com.algoTrader.entity.trade.IncrementalOrder))
        -> (timer:interval(5 sec) and not OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, ord.extId = currentOrder.extId))]
where
    not cast(currentOrder.parentOrder, com.algoTrader.entity.trade.IncrementalOrder).checkLimit();

// ------------------------------ Slicing Limit Order ---------------------------------------

@Name('SLICINING_DECREASE_OFFSET_TICKS')
@RunTimeOnly
@Subscriber(className='com.algoTrader.esper.subscriber.VoidSubscriber')
select
    cast(currentOrder.parentOrder, com.algoTrader.entity.trade.SlicingOrder).decreaseOffsetTicks()
from
    //every GenericOrder -> (OrderStatusC and not OrderStatusEorPE)
    pattern [every currentOrder=GenericOrder(instanceof(parentOrder,com.algoTrader.entity.trade.SlicingOrder))
        -> (OrderStatus(status = Status.CANCELED, ord.extId = currentOrder.extId)
            and not OrderStatus(status = Status.EXECUTED or status = Status.PARTIALLY_EXECUTED, ord.extId = currentOrder.extId))];

@Name('SLICINING_INCREASE_OFFSET_TICKS')
@RunTimeOnly
@Subscriber(className='com.algoTrader.esper.subscriber.VoidSubscriber')
select
    cast(currentOrder.parentOrder, com.algoTrader.entity.trade.SlicingOrder).increaseOffsetTicks()
from
    //every GenericOrder -> (OrderStatusEorPE and not OrderStatusC)
    pattern [every currentOrder=GenericOrder(instanceof(parentOrder,com.algoTrader.entity.trade.SlicingOrder))
        -> (OrderStatus(status = Status.EXECUTED or status = Status.PARTIALLY_EXECUTED, ord.extId = currentOrder.extId)
            and not OrderStatus(status = Status.CANCELED, ord.extId = currentOrder.extId))];

@Name('SLICINING_CANCEL_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.cancelOrder')
select
    currentOrder
from
    //every GenericOrder -> (timer:interval and not OrderStatusEorC)
    pattern [every currentOrder=GenericOrder(instanceof(parentOrder,com.algoTrader.entity.trade.SlicingOrder))
        -> (timer:interval(cast(currentOrder.parentOrder.minDuration?,double) + (cast(currentOrder.parentOrder.maxDuration?,double) - cast(currentOrder.parentOrder.minDuration?,double)) * Math.random())
            and not OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, ord.extId = currentOrder.extId))];

@Name('SLICINING_FIRST_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.sendOrder')
select
    slicingOrder.nextOrder(slicingOrder.quantity)
from
    com.algoTrader.entity.trade.SlicingOrder as slicingOrder;

@Name('SLICINING_NEXT_ORDER')
@RunTimeOnly
@Subscriber(className='com.algoTrader.service.OrderService.sendOrder')
select
    slicingOrder.nextOrder(openOrderWindow.remainingQuantity)
from
    // every SlicingOrder -> every ((OrderStatusLimit -> timer:interval) and not OrderStatusSlicing)
    pattern [every slicingOrder=com.algoTrader.entity.trade.SlicingOrder
            -> every ((OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, ord.parentOrder.extId = slicingOrder.extId)
            -> timer:interval(slicingOrder.minDelay + (slicingOrder.maxDelay - slicingOrder.minDelay) * Math.random()))
            and not OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, ord.extId = slicingOrder.extId))] unidirectional,
    OpenOrderWindow() as openOrderWindow
where
    openOrderWindow.extId = slicingOrder.extId;
