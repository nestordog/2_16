/*
 * Priorities on Tick:
 * Prio 4: CURRENT_MARKET_DATA_EVENT
 * Prio 3: UPDATE_COMPONENT_WINDOW
 * Prio 2: CLOSE_POSITION
 * Prio 1: PROPAGATE_MARKET_DATA_EVENTS
 */

@Name('TICK_WINDOW')
@RunTimeOnly()
create window
    TickWindow.std:groupwin(security.id, feedType).std:lastevent()
as select
    *,
    "" as tickerId,
    true as refresh
from
    Tick;

@Name('INSERT_INTO_TICK_WINDOW')
@RunTimeOnly()
insert into
    TickWindow
select
    tick.*,
    tickerId,
    true as refresh
from
    SubscribeTickEvent;

@Name('UPDATE_TICK_WINDOW_FROM_TRADE')
@RunTimeOnly()
on
    Trade as trade
update
    TickWindow as tickWindow
set
    tickWindow.dateTime = trade.lastDateTime,
    tickWindow.lastDateTime = trade.lastDateTime,
    tickWindow.last = (case when trade.last = 0 then null else RoundUtil.getBigDecimal(trade.last, tickWindow.security.securityFamily.scale) end),
    tickWindow.vol = trade.vol,
    tickWindow.refresh = true
where
    tickWindow.feedType = trade.feedType
and
    tickWindow.tickerId = trade.tickerId;

@Name('UPDATE_TICK_WINDOW_FROM_BID')
@RunTimeOnly()
on
    Bid as bid
update
    TickWindow as tickWindow
set
    tickWindow.dateTime = bid.dateTime,
    tickWindow.bid = (case when bid.bid = 0 then null else RoundUtil.getBigDecimal(bid.bid, tickWindow.security.securityFamily.scale) end),
    tickWindow.volBid = bid.volBid,
    tickWindow.refresh = true
where
    tickWindow.feedType = bid.feedType
and
    tickWindow.tickerId = bid.tickerId;

@Name('UPDATE_TICK_WINDOW_FROM_ASK')
@RunTimeOnly()
on
    Ask as ask
update
    TickWindow as tickWindow
set
    tickWindow.dateTime = ask.dateTime,
    tickWindow.ask = (case when ask.ask = 0 then null else RoundUtil.getBigDecimal(ask.ask, tickWindow.security.securityFamily.scale) end),
    tickWindow.volAsk = ask.volAsk,
    tickWindow.refresh = true
where
    tickWindow.feedType = ask.feedType
and
    tickWindow.tickerId = ask.tickerId;

@Name('INSERT_INTO_TICK')
@RunTimeOnly()
on
    TickWindow as trigger
insert into
    Tick
select
    transpose(ServiceUtil.completeTick(tickWindow))
from
    TickWindow as tickWindow
where
    trigger.security.id = tickWindow.security.id
and
    tickWindow.refresh
and
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    ServiceUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate());

@Name('CHECK_TICK_GAPS')
@Subscriber(className='ch.algotrader.service.MarketDataService.logTickGap')
@RunTimeOnly()
select
    tick.security.id
from
    pattern [every tick=Tick(not security.securityFamily.maxGap is null)
            -> (timer:interval(tick.security.securityFamily.maxGap * 60) and not Tick(security.id = tick.security.id))]
where
    ServiceUtil.isMarketOpen(tick.security.securityFamily, current_timestamp.toDate());

@Name('PROPAGATE_MARKET_DATA_EVENTS')
@Subscriber(className='ch.algotrader.esper.subscriber.PropagateMarketDataEventSubscriber')
@Priority(1)
select
    *
from
    MarketDataEvent
where
    security is not null;

@Name('PROPAGATE_GENERIC_EVENTS')
@Subscriber(className='ch.algotrader.esper.subscriber.PropagateGenericEventSubscriber')
@Priority(1)
select
    *
from
    ch.algotrader.vo.GenericEventVO;

@Name('PERSIST_HOUR_TICKS')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.esper.subscriber.PersistTickSubscriber')
on pattern
    [every timer:at(0, *, *, *, *)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    ServiceUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate())
and
    tickWindow.security.securityFamily.periodicity = TimePeriod.fromString('HOUR'); // (HOUR is a reserved keyword)

@Name('PERSIST_MINUTE_TICKS')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.esper.subscriber.PersistTickSubscriber')
on pattern
    [every timer:at(*, *, *, *, *)]
select
    *
from
    TickWindow as tickWindow
where
    tickWindow.security.validateTick(cast(tickWindow.getFirst(),ch.algotrader.entity.marketData.Tick))
and
    ServiceUtil.isMarketOpen(tickWindow.security.securityFamily, current_timestamp.toDate())
and
    tickWindow.security.securityFamily.periodicity = TimePeriod.fromString('MIN');

// ------------------------------TRADING STATUS--------------------------------

@Name('TRADING_CONTEXT')
create context
    TradingStatusContext
partition by
    feedType and tickerId
from
    TradingHaltVO;

@Name('TRADING_SUSPENDED')
@RunTimeOnly()
insert into
    TradingStatusEventVO
select
    TradingStatus.TRADING_HALT,
    tickWindow.security.id,
    halt.feedType,
    halt.dateTime
from
    TradingHaltVO as halt unidirectional,
    TickWindow as tickWindow
where
    tickWindow.feedType = halt.feedType
and
    tickWindow.tickerId = halt.tickerId;

@Name('TRADING_RESUMED')
@RunTimeOnly()
context TradingStatusContext
insert into
    TradingStatusEventVO
select
    TradingStatus.READY_TO_TRADE,
    tickWindow.security.id,
    halt.feedType,
    halt.dateTime
from
    pattern[every (halt=TradingHaltVO -> (
        Ask(tickerId=halt.tickerId, feedType=halt.feedType) or
        Bid(tickerId=halt.tickerId, feedType=halt.feedType) or
        Trade(tickerId=halt.tickerId, feedType=halt.feedType)))] unidirectional,
    TickWindow as tickWindow
where
    tickWindow.feedType = halt.feedType
and
    tickWindow.tickerId = halt.tickerId;
