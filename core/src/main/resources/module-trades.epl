// ------------------------------OPEN_ORDER_WINDOW--------------------------------

@Name('OPEN_ORDER_WINDOW')
create
    window OpenOrderWindow.std:groupwin(rootIntId).std:lastevent()
as select
    *,
    Status.OPEN as status,
    0L as filledQuantity,
    0L as remainingQuantity
from
    `Order`;

@Name('INSERT_INTO_OPEN_ORDER_WINDOW')
@RunTimeOnly()
insert into
    OpenOrderWindow
select
    *,
    Status.OPEN as status,
    0L as filledQuantity,
    quantity as remainingQuantity
from
    `Order`;

@Name('UPDATE_OPEN_ORDER_WINDOW')
@RunTimeOnly()
on
    OrderStatus as orderStatus
update
    OpenOrderWindow  as openOrderWindow
set
    openOrderWindow.status = orderStatus.status,
    openOrderWindow.filledQuantity = orderStatus.filledQuantity,
    openOrderWindow.remainingQuantity = orderStatus.remainingQuantity,
    openOrderWindow.intId = (case when orderStatus.intId is not null then orderStatus.intId else orderStatus.`order`.intId end),
    openOrderWindow.extId = (case when orderStatus.extId is not null then orderStatus.extId else orderStatus.`order`.extId end)
where
    openOrderWindow.intId = orderStatus.`order`.intId;

@Name('DELETE_FROM_OPEN_ORDER_WINDOW')
@RunTimeOnly()
on
    pattern[every orderStatus=OrderStatus(status = Status.EXECUTED or status = Status.CANCELED) -> timer:interval(1 sec)]
delete from
    OpenOrderWindow as openOrderWindow
where
    orderStatus.`order` is null
or
    orderStatus.`order`.intId = openOrderWindow.intId
or
    orderStatus.intId = openOrderWindow.intId;

@Name('INSERT_INTO_ORDER_COMPLETION')
@RunTimeOnly()
insert into
    OrderCompletion
select
    current_timestamp.toDate() as dateTime,
    orderStatus.status as status,
    orderStatus.filledQuantity as filledQuantity,
    orderStatus.remainingQuantity as remainingQuantity,
    orderStatus.`order` as `order`,
    sum(transaction.price * transaction.quantity) / sum(transaction.quantity) as avgPrice,
    sum(transaction.grossValue) as grossValue,
    sum(transaction.netValue) as netValue,
    sum(transaction.totalCharges) as totalCharges,
    cast(count(transaction),int) as fills,
    (current_timestamp - orderStatus.`order`.dateTime.toMillisec()) / 1000.0 as executionTime
from
    pattern[every currentOrder=`Order` ->
        (every transaction=Transaction(intOrderId = currentOrder.intId)
        and orderStatus=OrderStatus(`order`.intId = currentOrder.intId, status = Status.EXECUTED or status = Status.CANCELED)
        and not timer:interval(1 day))]
group by
    currentOrder.intId, orderStatus.filledQuantity
having
    sum(Math.abs(transaction.quantity)) = orderStatus.filledQuantity;

@Name('NOTIFY_MISSING_ORDER_REPLY')
@Subscriber(className='ch.algotrader.esper.subscriber.ExceptionSubscriber')
@RunTimeOnly()
select
    "missing reply on order: " || currentOrder.toString() as reason
from
    pattern[every currentOrder = `Order`(direct, not (tif=TIF.ATC or tif=TIF.ATO)) -> (timer:interval(misc_orderAckSeconds) and not OrderStatus(`order`.intId = currentOrder.intId))];

// ------------------------------ALGO ORDERS--------------------------------

@Name('SEND_INITIAL_ALGO_ORDERS')
@RunTimeOnly
@Subscriber(className='ch.algotrader.service.OrderService.sendOrders')
select
    currentOrder.getInitialOrders()
from
    ch.algotrader.entity.trade.AlgoOrder as currentOrder;

@Name('INSERT_INTO_ALGO_ORDER_STATUS_SUBMITTED')
@RunTimeOnly()
insert into
    OrderStatus
select
    Status.SUBMITTED as status,
    0 as filledQuantity,
    openOrderWindow.remainingQuantity as remainingQuantity,
    `order`.parentOrder as `order`
from
    OrderStatus(status = Status.SUBMITTED, `order`.parentOrder.algoOrder) as orderStatus unidirectional,
    OpenOrderWindow(status = Status.OPEN) as openOrderWindow
where
    openOrderWindow.intId = orderStatus.`order`.parentOrder.intId;

@Name('INSERT_INTO_ALGO_ORDER_STATUS_FROM_FILL')
@RunTimeOnly()
insert into
    OrderStatus
select
    case when openOrderWindow.remainingQuantity - fill.quantity > 0 then Status.PARTIALLY_EXECUTED else Status.EXECUTED end as status,
    openOrderWindow.filledQuantity + fill.quantity as filledQuantity,
    openOrderWindow.remainingQuantity - fill.quantity as remainingQuantity,
    `order`.parentOrder as `order`
from
    Fill(`order`.parentOrder.algoOrder) as fill unidirectional,
    OpenOrderWindow() as openOrderWindow
where
    openOrderWindow.intId = fill.`order`.parentOrder.intId;

@Name('ALGO_ORDER_DONE')
@RunTimeOnly
@Subscriber(className='ch.algotrader.esper.subscriber.VoidSubscriber')
select
    cast(`order`, ch.algotrader.entity.trade.AlgoOrder).done()
from
    OrderStatus(status = Status.EXECUTED or status = Status.CANCELED, `order`.algoOrder);

// ------------------------------LOGGING / PROPAGATION--------------------------------

@Name('LOG_TRANSACTION_SUMMARY')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.TransactionServiceImpl$LogTransactionSummarySubscriber')
select
    fill,
    orderStatus
from
    pattern [every fill=Fill -> orderStatus=OrderStatus(
        status = Status.EXECUTED or status = Status.CANCELED,
        (not fill.`order`.parentOrder is null and `order`.intId = fill.`order`.parentOrder.intId) or
        (fill.`order`.parentOrder is null and `order`.intId = fill.`order`.intId))];

@Name('PROPAGATE_ORDER_STATUS')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.OrderService.propagateOrderStatus')
select
    *
from
    OrderStatus;

@Name('PROPAGATE_ORDER_COMPLETION')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.OrderService.propagateOrderCompletion')
select
    *
from
    OrderCompletion;

@Name('PROPAGATE_FILL')
@Priority(1)
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.TransactionService.propagateFill')
select
    *
from
    Fill;

@Name('CREATE_TRANSACTION')
@RunTimeOnly()
@Subscriber(className='ch.algotrader.service.TransactionServiceImpl$CreateTransactionSubscriber')
select
    *
from
    Fill;
